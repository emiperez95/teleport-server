#!/usr/bin/env bash
# teleport - CLI wrapper for Claude Teleport Server

set -euo pipefail

CONFIG_DIR="${HOME}/.teleport"
HOSTS_FILE="${CONFIG_DIR}/hosts.json"

# ── Host management ──

_ensure_config_dir() {
  [ -d "$CONFIG_DIR" ] || mkdir -p "$CONFIG_DIR"
  [ -f "$HOSTS_FILE" ] || echo '{}' > "$HOSTS_FILE"
}

_get_host_config() {
  local name="$1"
  _ensure_config_dir
  jq -r --arg n "$name" '.[$n] // empty' "$HOSTS_FILE"
}

_get_default_host() {
  _ensure_config_dir
  jq -r '.["_default"] // empty' "$HOSTS_FILE"
}

_resolve_host() {
  # Priority: --host flag > env vars > default host > localhost
  if [ -n "${_HOST_FLAG:-}" ]; then
    local config
    config=$(_get_host_config "$_HOST_FLAG")
    if [ -n "$config" ]; then
      HOST=$(echo "$config" | jq -r '.host')
      PORT=$(echo "$config" | jq -r '.port // "8080"')
      SSH_PORT=$(echo "$config" | jq -r '.ssh_port // "2222"')
      SSH_USER=$(echo "$config" | jq -r '.ssh_user // "claude"')
    else
      # Treat as raw hostname
      HOST="$_HOST_FLAG"
      PORT="${TELEPORT_PORT:-8080}"
      SSH_PORT="${TELEPORT_SSH_PORT:-2222}"
      SSH_USER="${TELEPORT_SSH_USER:-claude}"
    fi
  elif [ -n "${TELEPORT_HOST:-}" ]; then
    HOST="$TELEPORT_HOST"
    PORT="${TELEPORT_PORT:-8080}"
    SSH_PORT="${TELEPORT_SSH_PORT:-2222}"
    SSH_USER="${TELEPORT_SSH_USER:-claude}"
  else
    local default_name
    default_name=$(_get_default_host)
    if [ -n "$default_name" ]; then
      local config
      config=$(_get_host_config "$default_name")
      if [ -n "$config" ]; then
        HOST=$(echo "$config" | jq -r '.host')
        PORT=$(echo "$config" | jq -r '.port // "8080"')
        SSH_PORT=$(echo "$config" | jq -r '.ssh_port // "2222"')
        SSH_USER=$(echo "$config" | jq -r '.ssh_user // "claude"')
      else
        HOST="localhost"
        PORT="8080"
        SSH_PORT="2222"
        SSH_USER="claude"
      fi
    else
      HOST="localhost"
      PORT="8080"
      SSH_PORT="2222"
      SSH_USER="claude"
    fi
  fi
  BASE_URL="http://${HOST}:${PORT}"
}

cmd_host() {
  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    add)
      local name="${1:?Usage: teleport host add <name> <address> [--port PORT] [--ssh-port PORT] [--ssh-user USER]}"
      local address="${2:?Usage: teleport host add <name> <address>}"
      shift 2
      local port="8080" ssh_port="2222" ssh_user="claude"
      while [ $# -gt 0 ]; do
        case "$1" in
          --port)     port="$2"; shift 2 ;;
          --ssh-port) ssh_port="$2"; shift 2 ;;
          --ssh-user) ssh_user="$2"; shift 2 ;;
          *)          shift ;;
        esac
      done
      _ensure_config_dir
      jq --arg n "$name" --arg h "$address" --arg p "$port" --arg sp "$ssh_port" --arg su "$ssh_user" \
        '.[$n] = {host: $h, port: $p, ssh_port: $sp, ssh_user: $su}' "$HOSTS_FILE" > "${HOSTS_FILE}.tmp" \
        && mv "${HOSTS_FILE}.tmp" "$HOSTS_FILE"
      echo "Added host '$name' → $address:$port (ssh: $ssh_port)"
      ;;
    remove|rm)
      local name="${1:?Usage: teleport host remove <name>}"
      _ensure_config_dir
      jq --arg n "$name" 'del(.[$n])' "$HOSTS_FILE" > "${HOSTS_FILE}.tmp" \
        && mv "${HOSTS_FILE}.tmp" "$HOSTS_FILE"
      echo "Removed host '$name'"
      ;;
    default)
      local name="${1:-}"
      _ensure_config_dir
      if [ -z "$name" ]; then
        local current
        current=$(_get_default_host)
        if [ -n "$current" ]; then
          echo "Default host: $current"
        else
          echo "No default host set"
        fi
        return
      fi
      jq --arg n "$name" '.["_default"] = $n' "$HOSTS_FILE" > "${HOSTS_FILE}.tmp" \
        && mv "${HOSTS_FILE}.tmp" "$HOSTS_FILE"
      echo "Default host set to '$name'"
      ;;
    list|ls|"")
      _ensure_config_dir
      local default_host
      default_host=$(_get_default_host)
      local hosts
      hosts=$(jq -r 'to_entries[] | select(.key != "_default") | .key' "$HOSTS_FILE")
      if [ -z "$hosts" ]; then
        echo "No hosts configured. Add one with: teleport host add <name> <address>"
        return
      fi
      printf "%-15s %-25s %-8s %-8s %s\n" "NAME" "ADDRESS" "PORT" "SSH" "DEFAULT"
      echo "$hosts" | while read -r name; do
        local h p sp marker=""
        h=$(jq -r --arg n "$name" '.[$n].host' "$HOSTS_FILE")
        p=$(jq -r --arg n "$name" '.[$n].port // "8080"' "$HOSTS_FILE")
        sp=$(jq -r --arg n "$name" '.[$n].ssh_port // "2222"' "$HOSTS_FILE")
        [ "$name" = "$default_host" ] && marker="*"
        printf "%-15s %-25s %-8s %-8s %s\n" "$name" "$h" "$p" "$sp" "$marker"
      done
      ;;
    *)
      echo "Usage: teleport host <add|remove|list|default> [args]"
      exit 1
      ;;
  esac
}

usage() {
  cat <<EOF
Usage: teleport <command> [options] [--host <name>]

Commands:
  setup                      Configure Claude auth, GitHub, git in container
  send <repo_url> [branch]   Create a session from a git repo
  beam                       Send current Claude session to the server
  list                       List all active sessions
  info <session_id>          Get session details
  attach <session_id>        SSH in and attach to a session's tmux
  kill <session_id>          Kill a session
  push <session_id> [msg]    Commit and push changes
  health                     Health check
  status                     Check server, GitHub, and Claude auth

  host add <name> <addr>     Register a host (--port, --ssh-port, --ssh-user)
  host remove <name>         Remove a host
  host list                  List registered hosts
  host default [name]        Get/set default host

Options:
  --host <name>              Use a registered host (or raw address)

Environment (overrides host config):
  TELEPORT_HOST       Server host (default: localhost)
  TELEPORT_PORT       API port (default: 8080)
  TELEPORT_SSH_PORT   SSH port (default: 2222)
  TELEPORT_SSH_USER   SSH user (default: claude)
EOF
  exit 1
}

cmd_send() {
  local repo_url="${1:?Usage: teleport send <repo_url> [branch]}"
  local branch="${2:-}"
  local body

  if [ -n "$branch" ]; then
    body=$(printf '{"repo_url":"%s","branch":"%s"}' "$repo_url" "$branch")
  else
    body=$(printf '{"repo_url":"%s"}' "$repo_url")
  fi

  _do_teleport "$body"
}

cmd_beam() {
  # Auto-detect everything from the current git project

  # Track temp files for cleanup
  declare -a tmpfiles
  _beam_cleanup() { [ "${#tmpfiles[@]}" -gt 0 ] && rm -f "${tmpfiles[@]}" 2>/dev/null || true; }
  trap _beam_cleanup RETURN

  # 1. Get repo URL (convert SSH to HTTPS for container compatibility)
  local repo_url
  repo_url=$(git remote get-url origin 2>/dev/null) || {
    echo "Error: Not in a git repository or no 'origin' remote"
    exit 1
  }
  # Convert git@github.com:user/repo.git → https://github.com/user/repo.git
  if [[ "$repo_url" == git@github.com:* ]]; then
    repo_url="https://github.com/${repo_url#git@github.com:}"
  fi

  # 2. Get current branch
  local branch
  branch=$(git branch --show-current 2>/dev/null) || branch="main"

  # 3. Find the project root
  local project_dir
  project_dir=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "Error: Cannot determine project root"
    exit 1
  }

  # Claude stores sessions at ~/.claude/projects/<path-hash>/
  local path_hash
  path_hash=$(echo "$project_dir" | sed 's|/|-|g')
  local sessions_dir="$HOME/.claude/projects/${path_hash}"

  echo "Detected:"
  echo "  Repo:    $repo_url"
  echo "  Branch:  $branch"
  echo "  Project: $project_dir"

  # 4. Find the most recent session file
  local session_file=""
  local resume_session_id=""

  if [ -d "$sessions_dir" ]; then
    session_file=$(ls -t "$sessions_dir"/*.jsonl 2>/dev/null | head -1) || true
  fi

  if [ -n "$session_file" ]; then
    resume_session_id=$(basename "$session_file" .jsonl)
    local session_size
    session_size=$(du -h "$session_file" | cut -f1)
    echo "  Session: $resume_session_id ($session_size)"
  else
    echo "  Session: (none, starting fresh)"
  fi

  # 5. Uncommitted changes (staged + unstaged vs HEAD)
  local has_diff=false
  local diff_b64_file=""
  local diff_output
  diff_output=$(cd "$project_dir" && git diff HEAD 2>/dev/null) || true
  if [ -n "$diff_output" ]; then
    diff_b64_file=$(mktemp)
    tmpfiles+=("$diff_b64_file")
    echo "$diff_output" | base64 > "$diff_b64_file"
    has_diff=true
    local diff_lines
    diff_lines=$(echo "$diff_output" | wc -l | tr -d ' ')
    echo "  Changes: $diff_lines lines of diff"
  else
    echo "  Changes: (clean)"
  fi

  # 6. CLAUDE.md from project root
  local has_claude_md=false
  local claude_md_b64_file=""
  if [ -f "$project_dir/CLAUDE.md" ]; then
    claude_md_b64_file=$(mktemp)
    tmpfiles+=("$claude_md_b64_file")
    base64 < "$project_dir/CLAUDE.md" > "$claude_md_b64_file"
    has_claude_md=true
    local md_size
    md_size=$(du -h "$project_dir/CLAUDE.md" | cut -f1)
    echo "  CLAUDE.md: yes ($md_size)"
  else
    echo "  CLAUDE.md: (not found)"
  fi

  # 7. .claude/ project config (settings, permissions, MCP)
  local has_config=false
  local config_json=""
  if [ -d "$project_dir/.claude" ]; then
    # settings.local.json → claude_config.settings + permissions
    if [ -f "$project_dir/.claude/settings.local.json" ]; then
      config_json=$(jq -n --slurpfile s "$project_dir/.claude/settings.local.json" '{settings: $s[0]}')
      # Extract permissions if nested inside settings
      local perms
      perms=$(jq '.permissions // empty' "$project_dir/.claude/settings.local.json" 2>/dev/null) || true
      if [ -n "$perms" ] && [ "$perms" != "null" ]; then
        config_json=$(echo "$config_json" | jq --argjson p "$perms" '. + {permissions: $p}')
      fi
      has_config=true
    fi
    # mcp.json
    if [ -f "$project_dir/.claude/mcp.json" ]; then
      if [ -n "$config_json" ]; then
        config_json=$(echo "$config_json" | jq --slurpfile m "$project_dir/.claude/mcp.json" '. + {mcp: $m[0]}')
      else
        config_json=$(jq -n --slurpfile m "$project_dir/.claude/mcp.json" '{mcp: $m[0]}')
      fi
      has_config=true
    fi
    if [ "$has_config" = true ]; then
      echo "  Config:   .claude/ settings included"
    fi
  fi

  echo ""
  echo "Beaming to server..."

  # Build JSON body incrementally
  local body_file
  body_file=$(mktemp)
  tmpfiles+=("$body_file")

  # Start with base fields
  jq -n --arg repo "$repo_url" --arg branch "$branch" \
    '{repo_url: $repo, branch: $branch}' > "$body_file"

  # Add session data if found
  if [ -n "$session_file" ]; then
    local session_b64_file
    session_b64_file=$(mktemp)
    tmpfiles+=("$session_b64_file")
    base64 < "$session_file" > "$session_b64_file"

    jq --rawfile data "$session_b64_file" --arg sid "$resume_session_id" \
      '. + {session_data: ($data | gsub("\n";"")), resume_session_id: $sid}' \
      "$body_file" > "${body_file}.tmp" && mv "${body_file}.tmp" "$body_file"
  fi

  # Add diff patch
  if [ "$has_diff" = true ]; then
    jq --rawfile patch "$diff_b64_file" \
      '. + {diff_patch: ($patch | gsub("\n";""))}' \
      "$body_file" > "${body_file}.tmp" && mv "${body_file}.tmp" "$body_file"
  fi

  # Add CLAUDE.md
  if [ "$has_claude_md" = true ]; then
    jq --rawfile md "$claude_md_b64_file" \
      '. + {claude_md: ($md | gsub("\n";""))}' \
      "$body_file" > "${body_file}.tmp" && mv "${body_file}.tmp" "$body_file"
  fi

  # Add claude_config
  if [ "$has_config" = true ]; then
    jq --argjson conf "$config_json" \
      '. + {claude_config: $conf}' \
      "$body_file" > "${body_file}.tmp" && mv "${body_file}.tmp" "$body_file"
  fi

  _do_teleport_file "$body_file"
}

_do_teleport_file() {
  local body_file="$1"

  local response
  response=$(curl -s -X POST "${BASE_URL}/teleport" \
    -H 'Content-Type: application/json' \
    --data-binary "@${body_file}")

  _show_result "$response"
}

_do_teleport() {
  local body="$1"

  local response
  response=$(curl -s -X POST "${BASE_URL}/teleport" \
    -H 'Content-Type: application/json' \
    -d "$body")

  _show_result "$response"
}

_show_result() {
  local response="$1"

  local session_id tmux_session work_dir status
  session_id=$(echo "$response" | jq -r '.session_id // empty')

  if [ -z "$session_id" ]; then
    echo "Error: $(echo "$response" | jq -r '.error // "Unknown error"')"
    echo "Details: $(echo "$response" | jq -r '.details // ""')"
    exit 1
  fi

  tmux_session=$(echo "$response" | jq -r '.tmux_session')
  work_dir=$(echo "$response" | jq -r '.work_dir')
  status=$(echo "$response" | jq -r '.status')

  echo ""
  echo "Session created:"
  echo "  ID:     $session_id"
  echo "  tmux:   $tmux_session"
  echo "  dir:    $work_dir"
  echo "  status: $status"
  echo ""
  echo "Attach with: teleport attach $session_id"
}

cmd_list() {
  local response
  response=$(curl -s "${BASE_URL}/sessions")

  local count
  count=$(echo "$response" | jq '.sessions | length')

  if [ "$count" = "0" ]; then
    echo "No active sessions."
    return
  fi

  printf "%-38s %-20s %-10s %s\n" "ID" "PROJECT" "STATUS" "TMUX"
  echo "$response" | jq -r '.sessions[] | "\(.id) \(.project) \(.status) \(.tmux_session)"' | \
    while read -r id project status tmux; do
      printf "%-38s %-20s %-10s %s\n" "$id" "$project" "$status" "$tmux"
    done
}

cmd_info() {
  local session_id="${1:?Usage: teleport info <session_id>}"

  curl -s "${BASE_URL}/sessions/${session_id}" | jq .
}

cmd_attach() {
  local session_id="${1:?Usage: teleport attach <session_id>}"

  # Get tmux session name from API
  local response
  response=$(curl -s "${BASE_URL}/sessions/${session_id}")

  local tmux_session
  tmux_session=$(echo "$response" | jq -r '.tmux_session // empty')

  if [ -z "$tmux_session" ]; then
    echo "Error: Session not found"
    exit 1
  fi

  echo "Attaching to $tmux_session..."
  echo "Password: claude"
  echo ""
  ssh -t -p "$SSH_PORT" "${SSH_USER}@${HOST}" "tmux attach -t ${tmux_session}"
}

cmd_kill() {
  local session_id="${1:?Usage: teleport kill <session_id>}"

  local response
  response=$(curl -s -X DELETE "${BASE_URL}/sessions/${session_id}")

  echo "$response" | jq -r '.message // .error'
}

cmd_push() {
  local session_id="${1:?Usage: teleport push <session_id> [message]}"
  local message="${2:-}"
  local body

  if [ -n "$message" ]; then
    body=$(printf '{"message":"%s"}' "$message")
  else
    body='{}'
  fi

  curl -s -X POST "${BASE_URL}/sessions/${session_id}/push" \
    -H 'Content-Type: application/json' \
    -d "$body" | jq .
}

cmd_setup() {
  echo "Connecting to container for setup..."
  echo "Password: claude"
  echo ""
  ssh -t -p "$SSH_PORT" "${SSH_USER}@${HOST}" "sudo bash /app/scripts/setup.sh"
}

cmd_status() {
  echo "Server: ${BASE_URL}"
  echo ""

  # 1. Server health
  local health
  health=$(curl -s --connect-timeout 5 "${BASE_URL}/health" 2>/dev/null) || {
    echo "  Server:  UNREACHABLE"
    return 1
  }
  local active
  active=$(echo "$health" | jq -r '.sessions.active')
  echo "  Server:  healthy ($active active sessions)"

  # 2. GitHub CLI
  local gh_status
  gh_status=$(curl -s --connect-timeout 5 "${BASE_URL}/health/auth" 2>/dev/null) || gh_status=""
  if [ -n "$gh_status" ]; then
    echo "  GitHub:  $(echo "$gh_status" | jq -r '.github // "unknown"')"
    echo "  Claude:  $(echo "$gh_status" | jq -r '.claude // "unknown"')"
  else
    echo "  Auth:    (auth endpoint not available)"
  fi
}

cmd_health() {
  curl -s "${BASE_URL}/health" | jq .
}

# Main — extract --host flag before dispatching
_HOST_FLAG=""
args=()
while [ $# -gt 0 ]; do
  case "$1" in
    --host) _HOST_FLAG="$2"; shift 2 ;;
    *)      args+=("$1"); shift ;;
  esac
done
set -- "${args[@]+"${args[@]}"}"

command="${1:-}"
shift || true

# Host command doesn't need connection resolution
if [ "$command" = "host" ]; then
  cmd_host "$@"
  exit 0
fi

_resolve_host

case "$command" in
  setup)   cmd_setup "$@" ;;
  send)    cmd_send "$@" ;;
  beam)    cmd_beam "$@" ;;
  list|ls) cmd_list "$@" ;;
  info)    cmd_info "$@" ;;
  attach)  cmd_attach "$@" ;;
  kill)    cmd_kill "$@" ;;
  push)    cmd_push "$@" ;;
  status)  cmd_status "$@" ;;
  health)  cmd_health "$@" ;;
  *)       usage ;;
esac
